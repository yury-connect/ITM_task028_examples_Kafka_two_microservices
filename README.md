# Пример взаимодействия через Kafka
## Микросервисная система, состоит из следующих сервисов:

---
## 1-й микросервис, **`user-pay-init-service`**
- Пользоваель через **REST** отправляет платеж, в котором указываются 3 поля:   
	- `имя пользователя` (String **userName**);
	- `сумма платежа` (int **amount**);
	- `валюта платежа` (Currency **currency**), `enum`;
- Платеж сохраняется в меснуб БД (`Postgres`), которая выдает **UIID id** платежа (`Hiber` генерирует при сохранении сущности);
- Далее платеж отправляется в `Kafka` (topic: "**payments**") для осуществления проводки платежа микросервисом **transaction-paymaster-service**;
- В случае успешной отправки в топик `Kafka` (topic: "**payments**"), данный микросервис присваивает платежу статус "**CREATED**" и обновляет статус в месной БД соответственно;
- Пользователь в ответ получает **UIID id** платежа и **StatusPayment status** плетежа (_status="CREATED"_);
- Далее проводкой платежа занимается микросервис **transaction-paymaster-service**, который обновляет (_меняет_) статусы в топике "**status-payments**" в зависимости от стадии проводки платежа.;
- Когда платеж полностью завершен и денежная транзакция проведена, платеж приобретает статус "**COMPLETED**" (этим занимается микросервис **transaction-paymaster-service**);
- Пользователь может в любой момент времени по **REST** запросу узнать текущее состояние платежа.;
  - в запросе пользователь отправляет **UIID id** платежа
  - и получает **StatusPayment status** статус платежа на данный момент;
- Пользователь может в любой момент времени по REST запросу получить свой платеж;
- Пользователь может в любой момент времени по REST запросу получить полный список всех своих платежей;
- В перспективе будет третий микросервис **"`Банк`"**, который по по **REST** будет получать более полную информацию о пользователе, чтобы идентифицировать его в системе и работать с его счетом/ деньгами;
- Все действия логируются в файл отчета.

---
## 2-й микросервис, **`transaction-paymaster-service`**
- Данный микросервис занимается **только проведением** платежа;
- Этот микросервис ничего не знает о пользователе, кроме его `id` **Long id**.;
- Вся информация о пользователе хранится в БД предыдущего микросервиса **user-pay-init-service** и доступна по REST;
- В перспективе будет третий микросервис **"`Банк`"**, куда текущий микросервис будет делать запрос по **REST**: есть-ли на счету у пользователя необходимая сумма?;
- т.к. система "_высоконагруженная_", то операции выолняются **не мгновенно**, а с некоторой рандомной задержной **от `0,5` до `5`** секунд! (_Реализовать это в коде_);
- Статус/ Результат при любом изменении отправляется в `Kafka`, в топик "**status-payments**";
- Финальная стадия успешно проведенного платежа - статус "**COMPLETED**"; 
- Финальная стадия отклоненного платежа - статус "**REJECTED**"; 
- Если при проведении платежа возникла ошибка - статус "**ERROR**";
- Все действия логируются в файл отчета.

--- 
## 3-й микросервис, **`money-storage-service`**
- Данный микросервис занимается **только хранением/ зачислением/ списанием** денег;
- Синхронно по **REST**, используя **WebClient** в **синхронном** режиме, обращается к **user-pay-init-service**, чтобы получить дополнительные сведения о пользователе, необходимые для аунтефикации/ авторизации;
- Асинхронно по **Kafka** получает информацию о том, что с пользователя нужно списать сумму, после чего
- проверяет счет и в случае успеха - пыполняет списание средств;
- Результат ложит в соответствующий топик;
- Имеет API для доступа клиента по REST. функционал:
  - пополнить счет;
  - списать средства (потратить);
  - посмотреть сумму на балансе;
  - посмотреть список операций за весь период или за выбранный;
- Сервис имеет свою собственную БД Postgres, где хранит средства, а так-же все операции по каждому счету;
- В плане авторизации сервис не хранит информацию о пользователе, а ходит каждый раз по **REST**, используя **WebClient** в **синхронном** режиме, в **user-pay-init-service**, откуда берет всю необходимую информацию;
- Все действия логируются в файл отчета.

---


